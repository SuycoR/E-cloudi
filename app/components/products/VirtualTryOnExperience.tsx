"use client";

import React, { useEffect, useMemo, useState, useRef } from "react";
import Link from "next/link";
import {
  UploadCloud,
  Sparkles,
  Loader2,
  CheckCircle,
  Save,
  X,
} from "lucide-react";
import { useCart } from "@/app/context/CartContext";
import type { ProductDetailProps } from "@/app/types/props";
import type { CartItem } from "@/app/types/itemCarrito";
import { sendGAEvent } from "@next/third-parties/google";
import type { UserAvatarRecord } from "@/types/avatar";

interface VirtualTryOnExperienceProps {
  product: ProductDetailProps;
}

interface ResultImage {
  id: string;
  label: string;
  url: string;
}

const BASE_GALLERY: ResultImage[] = [
  {
    id: "front",
    label: "Frontal",
    url: "https://images.unsplash.com/photo-1614699745279-2c61bd9d46b5",
  },
  {
    id: "side",
    label: "Lateral",
    url: "https://i0.wp.com/www.theclothesmaiden.com/wp-content/uploads/2024/01/brock-wegner-VYuV0yZc5eI-unsplash-scaled.jpg?fit=2048,2560&ssl=1",
  },
];

const FALLBACK_IMAGE =
  "https://img.freepik.com/vector-gratis/ilustracion-icono-doodle-engranaje_53876-5596.jpg?semt=ais_hybrid&w=740";

const PERSONALIZED_IMAGE_ID = "user-avatar";

const isObjectUrl = (value: string | null) =>
  Boolean(value && value.startsWith("blob:"));

const shouldSetCrossOrigin = (src: string) =>
  !(src.startsWith("data:") || src.startsWith("blob:"));

const loadImage = (src: string) =>
  new Promise<HTMLImageElement>((resolve, reject) => {
    const img = new Image();
    if (shouldSetCrossOrigin(src)) {
      img.crossOrigin = "anonymous";
    }
    img.onload = () => resolve(img);
    img.onerror = () =>
      reject(new Error(`No se pudo cargar la imagen de ${src}`));
    img.src = src;
  });

async function composeLookPreview(baseSrc: string, garmentSrc: string) {
  const [avatarImg, garmentImg] = await Promise.all([
    loadImage(baseSrc),
    loadImage(garmentSrc),
  ]);

  const width = avatarImg.naturalWidth || 900;
  const height = avatarImg.naturalHeight || 1200;
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) throw new Error("Canvas context no disponible");

  ctx.drawImage(avatarImg, 0, 0, width, height);

  const garmentWidth = garmentImg.naturalWidth || width;
  const garmentHeight = garmentImg.naturalHeight || height;
  const overlayWidth = Math.min(width * 0.78, garmentWidth);
  const overlayHeight = (overlayWidth / garmentWidth) * garmentHeight;

  ctx.globalAlpha = 0.7;
  ctx.drawImage(
    garmentImg,
    (width - overlayWidth) / 2,
    Math.max(height * 0.15, height / 2 - overlayHeight / 2),
    overlayWidth,
    overlayHeight
  );
  ctx.globalAlpha = 1;

  return canvas.toDataURL("image/png");
}

const VirtualTryOnExperience: React.FC<VirtualTryOnExperienceProps> = ({
  product,
}) => {
  const { addItem } = useCart();
  const [results] = useState<ResultImage[]>(BASE_GALLERY);
  const [selectedResult, setSelectedResult] = useState<ResultImage>(
    BASE_GALLERY[0]
  );
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);
  const [uploadedPreview, setUploadedPreview] = useState<string | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [progress, setProgress] = useState(0);
  const [statusMessage, setStatusMessage] = useState<string | null>(null);
  const [showSuccessModal, setShowSuccessModal] = useState(false);
  const [, setModalInsertedIds] = useState<number[]>([]);
  const [modalLoading, setModalLoading] = useState(false);
  const [modalError, setModalError] = useState<string | null>(null);
  const [avatarRecord, setAvatarRecord] = useState<UserAvatarRecord | null>(
    null
  );
  const [fusionPreview, setFusionPreview] = useState<string | null>(null);
  const [personalizedAutoSelected, setPersonalizedAutoSelected] =
    useState(false);
  // State for AI-generated results and toggle between preview/generated
  const [aiGeneratedResults, setAiGeneratedResults] = useState<ResultImage[]>(
    []
  );
  const [showAiGenerated, setShowAiGenerated] = useState(false);
  const hasAiResults = aiGeneratedResults.length > 0;

  // Track if we've already auto-generated to prevent double calls
  const hasAutoGenerated = useRef(false);

  const basePrice = useMemo(() => {
    const priceNumber = Number(product.precio ?? 0);
    return Number.isFinite(priceNumber) ? priceNumber : 0;
  }, [product.precio]);

  const finalPrice = useMemo(() => {
    if (product.descuento != null) {
      const discount = Number(product.descuento);
      const multiplier = Number.isFinite(discount) ? 1 - discount : 1;
      const computed = basePrice * multiplier;
      return Number.isFinite(computed)
        ? Number(computed.toFixed(2))
        : basePrice;
    }
    return basePrice;
  }, [basePrice, product.descuento]);

  useEffect(() => {
    if (!isGenerating) return;
    const interval = setInterval(() => {
      setProgress((prev) => {
        if (prev >= 95) return prev;
        const step = Math.random() * 12;
        const next = prev + step;
        return next >= 95 ? 95 : next;
      });
    }, 250);

    return () => clearInterval(interval);
  }, [isGenerating]);

  useEffect(() => {
    if (isGenerating || progress === 0) return;
    if (progress < 100) {
      setProgress(100);
    }
    const timeout = setTimeout(() => setProgress(0), 600);
    return () => clearTimeout(timeout);
  }, [isGenerating, progress]);

  useEffect(() => {
    return () => {
      if (uploadedPreview && isObjectUrl(uploadedPreview)) {
        URL.revokeObjectURL(uploadedPreview);
      }
    };
  }, [uploadedPreview]);

  useEffect(() => {
    let cancelled = false;

    const loadAvatar = async () => {
      try {
        const response = await fetch("/api/avatar");
        if (cancelled) return;
        if (!response.ok) {
          if (response.status !== 401) {
            console.warn("No se pudo obtener el avatar guardado");
          }
          setAvatarRecord(null);
          return;
        }
        const data = await response.json();
        setAvatarRecord(data.avatar ?? null);
      } catch (error) {
        if (!cancelled) {
          console.warn("Error al cargar avatar para try-on", error);
        }
      }
    };

    loadAvatar();

    return () => {
      cancelled = true;
    };
  }, []);

  useEffect(() => {
    if (avatarRecord?.imagenAvatar && !uploadedFile) {
      setUploadedPreview(avatarRecord.imagenAvatar);
    }
  }, [avatarRecord?.imagenAvatar, uploadedFile]);

  // Auto-generate try-on when avatar is loaded (on mount)
  useEffect(() => {
    if (
      avatarRecord?.imagenAvatar &&
      product.id_producto_especifico &&
      !hasAutoGenerated.current &&
      !isGenerating &&
      aiGeneratedResults.length === 0
    ) {
      hasAutoGenerated.current = true;
      // Small delay to ensure component is fully mounted
      const timer = setTimeout(() => {
        handleGenerate();
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [avatarRecord?.imagenAvatar, product.id_producto_especifico]);

  useEffect(() => {
    if (typeof window === "undefined") return;
    if (!product.imagen_producto) {
      setFusionPreview(null);
      return;
    }

    const baseSource = uploadedPreview || avatarRecord?.imagenAvatar;
    if (!baseSource) {
      setFusionPreview(null);
      return;
    }

    let cancelled = false;

    const buildPreview = async () => {
      try {
        const fused = await composeLookPreview(
          baseSource,
          product.imagen_producto as string
        );
        if (!cancelled) {
          setFusionPreview(fused);
        }
      } catch (error) {
        if (!cancelled) {
          console.warn(
            "No fue posible fusionar la prenda con tu avatar",
            error
          );
          setFusionPreview(null);
        }
      }
    };

    buildPreview();

    return () => {
      cancelled = true;
    };
  }, [uploadedPreview, avatarRecord?.imagenAvatar, product.imagen_producto]);

  const personalizedResult = useMemo(() => {
    // Priority: fusionPreview > uploadedPreview > avatarRecord
    const personalizedUrl =
      fusionPreview ?? uploadedPreview ?? avatarRecord?.imagenAvatar;
    if (!personalizedUrl) return null;
    return {
      id: PERSONALIZED_IMAGE_ID,
      label: fusionPreview
        ? "Look personalizado"
        : uploadedPreview
        ? "Nueva foto"
        : "Mi avatar",
      url: personalizedUrl,
    } satisfies ResultImage;
  }, [fusionPreview, uploadedPreview, avatarRecord?.imagenAvatar]);

  const displayedResults = useMemo(() => {
    if (!personalizedResult) return results;
    const others = results.filter((img) => img.id !== PERSONALIZED_IMAGE_ID);
    return [personalizedResult, ...others];
  }, [personalizedResult, results]);

  useEffect(() => {
    if (!personalizedResult) {
      setPersonalizedAutoSelected(false);
      return;
    }
    if (!personalizedAutoSelected) {
      setSelectedResult(personalizedResult);
      setPersonalizedAutoSelected(true);
    }
  }, [personalizedResult, personalizedAutoSelected]);

  useEffect(() => {
    if (!displayedResults.length) return;
    if (!selectedResult) {
      setSelectedResult(displayedResults[0]);
      return;
    }
    const stillExists = displayedResults.some(
      (image) => image.id === selectedResult.id
    );
    if (!stillExists) {
      setSelectedResult(displayedResults[0]);
    }
  }, [displayedResults, selectedResult]);

  const handleFileChange = async (
    event: React.ChangeEvent<HTMLInputElement>
  ) => {
    const file = event.target.files?.[0] ?? null;
    if (!file) {
      setUploadedFile(null);
      setUploadedPreview(null);
      return;
    }

    // Clean up previous preview
    if (uploadedPreview && isObjectUrl(uploadedPreview)) {
      URL.revokeObjectURL(uploadedPreview);
    }

    // Set file and show local preview immediately
    setUploadedFile(file);
    const localPreview = URL.createObjectURL(file);
    setUploadedPreview(localPreview);

    // Reset AI results to show the new preview
    setAiGeneratedResults([]);
    setShowAiGenerated(false);

    // Update the selected result to show the new image in the main viewer
    setSelectedResult({
      id: PERSONALIZED_IMAGE_ID,
      label: "Nueva foto",
      url: localPreview,
    });

    setStatusMessage("Subiendo nueva foto como avatar...");

    try {
      // Upload to /api/avatar to update the user's avatar in the database
      const form = new FormData();
      form.append("avatarImage", file);

      const response = await fetch("/api/avatar", {
        method: "POST",
        body: form,
      });

      if (!response.ok) {
        throw new Error("Error al subir la imagen");
      }

      const data = await response.json();

      if (data.ok && data.avatar) {
        // Update avatar record with the new S3 URL
        setAvatarRecord(data.avatar);
        // Update preview to use the S3 URL instead of blob
        if (data.avatar.imagenAvatar) {
          setUploadedPreview(data.avatar.imagenAvatar);
          setSelectedResult({
            id: PERSONALIZED_IMAGE_ID,
            label: "Nueva foto",
            url: data.avatar.imagenAvatar,
          });
        }
        setStatusMessage(
          "¡Foto subida! Presiona 'Generar' para crear las vistas con IA."
        );
      } else {
        throw new Error(data.error || "Error desconocido");
      }
    } catch (e) {
      console.error("Failed to upload avatar", e);
      setStatusMessage("Error al subir la foto. Intenta de nuevo.");
    }
  };

  /**
   * Calls the Gemini 2.5 (Nanobanana) API endpoint to generate virtual try-on images
   * Uses avatar from DB and product image to create 3 views: frontal, back, lateral
   */
  const callGeminiTryOnAPI = async (
    productId: number
  ): Promise<ResultImage[]> => {
    const response = await fetch("/api/tryon", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ productId }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        errorData.error || `Error del servidor: ${response.status}`
      );
    }

    const data = await response.json();

    if (!data.success || !data.views || data.views.length === 0) {
      throw new Error(data.error || "No se generaron imágenes");
    }

    return data.views as ResultImage[];
  };

  const handleGenerate = async () => {
    // Check if user has an avatar (either uploaded or saved in DB)
    if (!uploadedFile && !avatarRecord?.imagenAvatar) {
      setStatusMessage("Primero sube una foto o crea tu avatar virtual.");
      return;
    }

    // Check if product has an ID
    if (!product.id_producto_especifico) {
      setStatusMessage("Error: El producto no tiene un identificador válido.");
      return;
    }

    setIsGenerating(true);
    setStatusMessage(
      "Analizando tu foto y aplicando la prenda con Gemini 2.5..."
    );

    try {
      // If user uploaded a new file, upload it to their avatar first
      if (uploadedFile) {
        try {
          setStatusMessage("Guardando tu foto...");
          const form = new FormData();
          form.append("original", uploadedFile);
          await fetch("/api/uploads", { method: "POST", body: form });
        } catch (e) {
          console.warn("Failed to upload photo before generation", e);
        }
      }

      setStatusMessage("Generando vistas con inteligencia artificial...");

      // Call the Gemini 2.5 API for virtual try-on
      const generatedViews = await callGeminiTryOnAPI(
        product.id_producto_especifico
      );

      // Store AI-generated results separately
      setAiGeneratedResults(generatedViews);
      setShowAiGenerated(true);

      // Auto-select the first generated view
      if (generatedViews.length > 0) {
        setSelectedResult(generatedViews[0]);
      }

      setStatusMessage(
        `¡Listo! Se generaron ${generatedViews.length} vistas del probador virtual.`
      );
    } catch (error) {
      console.error("Virtual try-on error:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Error desconocido";
      setStatusMessage(`No pudimos generar el try-on: ${errorMessage}`);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSelectResult = (image: ResultImage) => {
    setSelectedResult(image);
  };

  const handleAddToCart = async () => {
    if (!product.id_producto_especifico) return;
    const descuento = product.descuento ?? 0;
    const item: CartItem = {
      productId: product.id_producto_especifico,
      nombre: product.nombre,
      descripcion: product.descripcion || "",
      image_producto: product.imagen_producto || "",
      cantidad: 1,
      precio: finalPrice,
      precioOriginal: basePrice,
      descuento,
    };

    try {
      await addItem(item);
      sendGAEvent("event", "add_to_cart", {
        item_id: product.id_producto_especifico,
        item_name: product.nombre,
        category: "Productos",
        price: finalPrice,
        quantity: 1,
      });
      setStatusMessage("Producto añadido al carrito correctamente.");
    } catch (error) {
      console.error("Error al agregar al carrito desde virtual try-on:", error);
      setStatusMessage("No pudimos añadir el producto al carrito.");
    }
  };

  // Helper: convert data URL to File
  const dataURLToFile = (dataUrl: string, filename: string) => {
    const arr = dataUrl.split(",");
    const mimeMatch = arr[0].match(/:(.*?);/);
    const mime = mimeMatch ? mimeMatch[1] : "image/jpeg";
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new File([u8arr], filename, { type: mime });
  };

  const showProgressBar = isGenerating || progress > 0;

  return (
    <section className="space-y-10 py-10">
      <header className="space-y-3 text-center">
        <p className="text-sm font-semibold uppercase tracking-[0.35em] text-sky-600">
          StyleHub Virtual Try-On
        </p>
        <h1 className="text-3xl font-bold text-slate-900">Virtual Try On</h1>
        <p className="mx-auto max-w-2xl text-sm text-slate-600">
          Usa tu avatar virtual y deja que nuestra IA con Gemini 2.5 adapte
          <span className="font-semibold text-slate-900">
            {" "}
            {product.nombre}
          </span>{" "}
          a tu estilo. Generaremos vistas en diferentes ángulos: frontal y
          lateral.
        </p>
      </header>

      {showProgressBar && (
        <div className="mx-auto flex max-w-2xl flex-col gap-2 animate-fade-in">
          {/* Enhanced progress bar with stages */}
          <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 border border-slate-200/20 shadow-lg">
            <div className="flex items-center justify-between mb-3">
              <div className="flex items-center gap-2">
                <Sparkles className="h-5 w-5 text-sky-400 animate-pulse" />
                <span className="text-sm font-semibold text-slate-200">
                  {isGenerating ? "Generando con Gemini 2.5" : "Procesando"}
                </span>
              </div>
              <span className="text-lg font-bold text-sky-400">
                {Math.round(progress)}%
              </span>
            </div>

            <div className="h-3 w-full overflow-hidden rounded-full bg-slate-700/50">
              <div
                className="h-full bg-gradient-to-r from-sky-500 via-purple-500 to-pink-500 transition-all duration-300 ease-out relative overflow-hidden"
                style={{ width: `${Math.min(progress, 100)}%` }}
              >
                <div className="absolute inset-0 bg-white/20 animate-shimmer" />
              </div>
            </div>

            {/* Status steps */}
            <div className="mt-4 flex items-center justify-between text-xs">
              <div
                className={`flex items-center gap-1.5 ${
                  progress > 0 ? "text-green-400" : "text-slate-400"
                }`}
              >
                <div
                  className={`w-2 h-2 rounded-full ${
                    progress > 0 ? "bg-green-400" : "bg-slate-500"
                  }`}
                />
                Analizando
              </div>
              <div
                className={`flex items-center gap-1.5 ${
                  progress > 30 ? "text-green-400" : "text-slate-400"
                }`}
              >
                <div
                  className={`w-2 h-2 rounded-full ${
                    progress > 30 ? "bg-green-400" : "bg-slate-500"
                  }`}
                />
                Procesando
              </div>
              <div
                className={`flex items-center gap-1.5 ${
                  progress > 60 ? "text-green-400" : "text-slate-400"
                }`}
              >
                <div
                  className={`w-2 h-2 rounded-full ${
                    progress > 60 ? "bg-green-400" : "bg-slate-500"
                  }`}
                />
                Generando
              </div>
              <div
                className={`flex items-center gap-1.5 ${
                  progress >= 95 ? "text-green-400" : "text-slate-400"
                }`}
              >
                <div
                  className={`w-2 h-2 rounded-full ${
                    progress >= 95 ? "bg-green-400" : "bg-slate-500"
                  }`}
                />
                Finalizando
              </div>
            </div>

            <p className="mt-3 text-xs font-medium text-slate-400 text-center">
              {isGenerating
                ? progress < 30
                  ? "Analizando tu foto y la prenda..."
                  : progress < 60
                  ? "Procesando la fusión de imágenes..."
                  : progress < 95
                  ? "Generando las vistas con IA..."
                  : "Finalizando, casi listo..."
                : statusMessage}
            </p>
          </div>
        </div>
      )}

      <div className="flex flex-col gap-8 lg:flex-row lg:items-start">
        {/* Left: large main viewer */}
        <div className="relative flex-1 overflow-hidden rounded-3xl border panel-dark shadow-lg min-h-[640px]">
          <img
            src={selectedResult?.url || FALLBACK_IMAGE}
            alt={`Vista ${selectedResult?.label ?? "generada"}`}
            className="h-full w-full object-cover"
          />

          <label
            htmlFor="virtual-try-on-upload"
            className="group absolute bottom-6 left-6 flex cursor-pointer items-center gap-2 rounded-md bg-black/60 px-4 py-2 text-sm font-medium text-white shadow-lg transition hover:bg-black/80"
          >
            <UploadCloud className="h-4 w-4" />
            Upload Photo
            <input
              id="virtual-try-on-upload"
              type="file"
              accept="image/*"
              className="hidden"
              onChange={handleFileChange}
            />
          </label>

          {(uploadedPreview || avatarRecord?.imagenAvatar) && !isGenerating && (
            <span className="absolute bottom-6 right-6 rounded-full bg-white/80 px-3 py-1 text-xs font-medium text-slate-700 shadow">
              {uploadedFile?.name || (avatarRecord ? "Avatar guardado" : "")}
            </span>
          )}

          {isGenerating && (
            <div className="absolute inset-0 flex flex-col items-center justify-center gap-4 bg-black/40 backdrop-blur-sm animate-fade-in">
              <div className="relative">
                <div className="absolute inset-0 rounded-full bg-sky-400/30 animate-pulse-ring" />
                <div className="relative w-16 h-16 rounded-full bg-gradient-to-r from-sky-500 to-purple-500 flex items-center justify-center">
                  <Loader2 className="h-8 w-8 animate-spin text-white" />
                </div>
              </div>
              <div className="text-center">
                <p className="text-base font-semibold text-white">
                  Generando tu look virtual
                </p>
                <p className="text-sm text-white/80 mt-1">
                  {progress < 30
                    ? "Analizando tu avatar..."
                    : progress < 60
                    ? "Aplicando la prenda..."
                    : progress < 95
                    ? "Creando las vistas..."
                    : "Finalizando..."}
                </p>
              </div>
            </div>
          )}
        </div>

        {/* Right: stacked thumbnails + actions */}
        <aside className="w-full max-w-xs">
          <h2 className="text-sm font-semibold text-slate-200 mb-3">
            {showAiGenerated && hasAiResults
              ? "Vistas generadas con IA"
              : "Explora más fotos"}
          </h2>

          {/* Toggle button between preview and AI-generated */}
          {hasAiResults && (
            <button
              type="button"
              onClick={() => {
                setShowAiGenerated(!showAiGenerated);
                // Select first image of the new view
                const newResults = !showAiGenerated
                  ? aiGeneratedResults
                  : displayedResults;
                if (newResults.length > 0) {
                  setSelectedResult(newResults[0]);
                }
              }}
              className="w-full mb-4 rounded-lg bg-gradient-to-r from-violet-600 to-sky-600 py-2.5 px-4 text-sm font-semibold text-white shadow-md transition hover:from-violet-700 hover:to-sky-700 flex items-center justify-center gap-2"
            >
              <Sparkles className="h-4 w-4" />
              {showAiGenerated
                ? "Ver vista previa original"
                : "Ver imágenes generadas con IA"}
            </button>
          )}

          <div className="flex flex-col gap-4">
            {/* Show thumbnails only when AI results exist, otherwise show single preview info */}
            {showAiGenerated && hasAiResults ? (
              // Show AI generated thumbnails (2 views)
              aiGeneratedResults.slice(0, 2).map((image) => {
                const isActive = image.id === selectedResult?.id;
                return (
                  <button
                    type="button"
                    key={image.id}
                    onClick={() => handleSelectResult(image)}
                    className={`relative overflow-hidden rounded-lg border ${
                      isActive
                        ? "border-sky-500 ring-2 ring-sky-200"
                        : "border-transparent"
                    } bg-white/5 shadow-sm transition hover:shadow-md`}
                  >
                    <img
                      src={image.url}
                      alt={`Vista ${image.label}`}
                      className="h-40 w-full object-cover rounded-md"
                    />
                    <span className="absolute bottom-2 left-2 rounded-full bg-black/60 px-3 py-1 text-xs font-semibold text-white">
                      {image.label}
                    </span>
                    <span className="absolute top-2 right-2 rounded-full bg-violet-600 px-2 py-0.5 text-xs font-semibold text-white">
                      IA
                    </span>
                  </button>
                );
              })
            ) : (
              // Show single preview message when no AI results or showing preview
              <div className="rounded-lg border border-slate-600 bg-white/5 p-4 text-center">
                <p className="text-sm text-slate-300">
                  {isGenerating
                    ? "Generando vistas con IA..."
                    : "Vista previa del avatar"}
                </p>
              </div>
            )}

            <div className="mt-2">
              <button
                type="button"
                onClick={handleAddToCart}
                className="w-full rounded-md bg-ebony-800 py-3 text-sm font-semibold text-white shadow-sm transition hover:bg-ebony-900"
              >
                Añadir al carrito
              </button>
            </div>

            {/* Guardar Look button - only show when AI results exist */}
            {hasAiResults && (
              <button
                onClick={async () => {
                  // Guardar Look: subir directamente las imágenes generadas desde el cliente
                  try {
                    // open modal in loading state
                    setModalInsertedIds([]);
                    setModalError(null);
                    setShowSuccessModal(true);
                    setModalLoading(true);

                    const form = new FormData();

                    // Attach product metadata
                    if (product.id_producto_especifico) {
                      form.append(
                        "productId",
                        String(product.id_producto_especifico)
                      );
                    }
                    form.append("guarda_resultado", "si");

                    // Convert each generated URL to a File and append
                    for (let i = 0; i < displayedResults.length; i++) {
                      const url = displayedResults[i].url;
                      try {
                        let file: File | null = null;
                        if (url.startsWith("data:")) {
                          file = dataURLToFile(url, `look_${i}.jpg`);
                        } else {
                          // fetch remote image from client and convert to blob
                          const r = await fetch(url);
                          if (!r.ok) {
                            console.warn(
                              "Skipping image, client fetch failed:",
                              url
                            );
                            continue;
                          }
                          const blob = await r.blob();
                          file = new File([blob], `look_${i}.jpg`, {
                            type: blob.type || "image/jpeg",
                          });
                        }
                        if (file) {
                          form.append("file", file);
                        }
                      } catch (e) {
                        console.warn(
                          "Failed to convert/attach image",
                          displayedResults[i].url,
                          e
                        );
                        continue;
                      }
                    }

                    const res = await fetch("/api/uploads", {
                      method: "POST",
                      body: form,
                    });
                    const json = await res.json();
                    if (json.ok) {
                      const uploaded = json.uploaded || [];
                      const inserted = (uploaded
                        .map((u: any) => u.insertedId)
                        .filter(Boolean) || []) as number[];
                      setModalInsertedIds(inserted);
                      setModalLoading(false);
                      if (inserted.length > 0) {
                        setStatusMessage(
                          `Look guardado correctamente (ids: ${inserted.join(
                            ","
                          )}).`
                        );
                      } else {
                        setStatusMessage("Look guardado correctamente.");
                      }
                    } else {
                      const msg = json?.error || "No se pudo guardar el look.";
                      setModalError(String(msg));
                      setModalLoading(false);
                      setStatusMessage("No se pudo guardar el look.");
                    }
                  } catch (e) {
                    console.error("Guardar Look error", e);
                    setModalLoading(false);
                    setModalError("Error al guardar el look.");
                    setStatusMessage("Error al guardar el look.");
                  }
                }}
                className="w-full mt-2 rounded-md bg-violet-600 text-white py-2.5 px-3 font-semibold flex items-center justify-center gap-2"
              >
                <Save className="h-4 w-4" />
                Guardar Look
              </button>
            )}

            <div className="rounded-3xl border border-slate-200 bg-white/5 p-4 shadow-sm mt-6">
              <div className="flex items-center gap-3">
                <Sparkles className="h-5 w-5 text-sky-400" />
                <p className="text-sm font-semibold text-slate-200">
                  {uploadedFile
                    ? "Foto lista"
                    : avatarRecord?.imagenAvatar
                    ? "Avatar guardado listo"
                    : "Sube una foto"}
                </p>
              </div>
              <p className="mt-2 text-xs text-slate-400">
                {uploadedFile || avatarRecord?.imagenAvatar
                  ? hasAiResults
                    ? "Puedes regenerar el look o subir una nueva foto."
                    : "Generando tu fitting virtual automáticamente..."
                  : "Sube una foto frontal para obtener el mejor resultado."}
              </p>
              <div className="mt-4 flex gap-2">
                <button
                  type="button"
                  onClick={handleGenerate}
                  disabled={
                    isGenerating ||
                    (!uploadedFile && !avatarRecord?.imagenAvatar)
                  }
                  className="flex-1 rounded-full bg-sky-600 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-sky-700 disabled:cursor-not-allowed disabled:opacity-60"
                >
                  {isGenerating
                    ? "Generando..."
                    : hasAiResults
                    ? "Regenerar"
                    : "Generar look"}
                </button>
              </div>
            </div>

            <div className="rounded-3xl border border-slate-200 bg-white/5 p-4 shadow-sm mt-6">
              <p className="text-sm font-semibold text-slate-200">
                {product.nombre}
              </p>
              <p className="text-xs text-slate-400">SKU: {product.SKU}</p>
              <div className="mt-3 flex items-baseline gap-2">
                <span className="text-xl font-bold text-slate-200">
                  S/ {finalPrice.toFixed(2)}
                </span>
                {product.descuento != null && (
                  <span className="text-xs text-slate-400 line-through">
                    S/ {basePrice.toFixed(2)}
                  </span>
                )}
              </div>
              <Link
                href={`/productos/${product.id_producto_especifico}`}
                className="mt-3 inline-flex w-full items-center justify-center rounded-full border border-slate-700 px-4 py-2 text-xs font-semibold text-slate-100 transition hover:border-slate-500 hover:bg-white/5"
              >
                Volver al producto
              </Link>
            </div>

            {statusMessage && !showProgressBar && (
              <div className="rounded-2xl border border-slate-200 bg-white/5 p-4 text-center text-xs text-slate-300 shadow-sm mt-4">
                {statusMessage}
              </div>
            )}
          </div>
        </aside>
      </div>

      {/* Success / Loading modal - Diseño unificado siguiendo Nielsen #4 (Consistencia) */}
      {showSuccessModal && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center"
          role="dialog"
          aria-modal="true"
          aria-labelledby="modal-title"
        >
          <div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={() => {
              if (!modalLoading) setShowSuccessModal(false);
            }}
          />

          <div className="relative max-w-md w-full mx-4 bg-white rounded-2xl shadow-2xl overflow-hidden animate-scale-in">
            {/* Success Icon - Similar al de confirmación de compra */}
            <div className="pt-8 pb-4 flex justify-center">
              <div
                className={`w-20 h-20 rounded-full flex items-center justify-center ${
                  modalLoading
                    ? "bg-sky-100"
                    : modalError
                    ? "bg-red-100"
                    : "bg-green-100"
                }`}
              >
                {modalLoading ? (
                  <Loader2 className="w-10 h-10 text-sky-500 animate-spin" />
                ) : modalError ? (
                  <X className="w-10 h-10 text-red-500" />
                ) : (
                  <CheckCircle className="w-10 h-10 text-green-500" />
                )}
              </div>
            </div>

            {/* Content */}
            <div className="px-6 pb-6 text-center">
              <h3
                id="modal-title"
                className="text-xl font-bold text-gray-900 mb-2"
              >
                {modalLoading
                  ? "Guardando tu look..."
                  : modalError
                  ? "No se pudo guardar"
                  : "¡Look guardado!"}
              </h3>

              <p className="text-gray-600 text-sm mb-6">
                {modalLoading
                  ? "Estamos subiendo tus imágenes a la nube. Esto puede tardar unos segundos."
                  : modalError
                  ? modalError
                  : "Tu look se ha guardado correctamente en tu galería personal."}
              </p>

              {/* Progress bar for loading state - Nielsen #1 (Visibilidad del estado) */}
              {modalLoading && (
                <div className="mb-6">
                  <div className="h-2 bg-gray-100 rounded-full overflow-hidden">
                    <div className="h-full bg-gradient-to-r from-sky-500 to-purple-500 rounded-full animate-progress-indeterminate" />
                  </div>
                  <p className="text-xs text-gray-500 mt-2">
                    Por favor no cierres esta ventana
                  </p>
                </div>
              )}

              {/* Success message with helpful info */}
              {!modalLoading && !modalError && (
                <div className="bg-green-50 rounded-xl p-4 mb-6 text-left">
                  <p className="text-sm text-green-800">
                    Puedes ver todos tus looks guardados en tu perfil, sección
                    &ldquo;Mis Looks&rdquo;.
                  </p>
                </div>
              )}

              {/* Error retry suggestion */}
              {!modalLoading && modalError && (
                <div className="bg-red-50 rounded-xl p-4 mb-6 text-left">
                  <p className="text-sm text-red-800">
                    Verifica tu conexión a internet e intenta nuevamente.
                  </p>
                </div>
              )}

              {/* Action button */}
              <button
                disabled={modalLoading}
                className={`w-full py-3 px-6 rounded-full font-semibold transition-all ${
                  modalLoading
                    ? "bg-gray-200 text-gray-500 cursor-not-allowed"
                    : modalError
                    ? "bg-red-500 text-white hover:bg-red-600"
                    : "bg-green-500 text-white hover:bg-green-600"
                }`}
                onClick={() => {
                  setShowSuccessModal(false);
                  setModalError(null);
                  setModalInsertedIds([]);
                }}
              >
                {modalLoading
                  ? "Guardando..."
                  : modalError
                  ? "Cerrar"
                  : "Continuar"}
              </button>
            </div>
          </div>
        </div>
      )}
    </section>
  );
};

export default VirtualTryOnExperience;
